#! /usr/bin/env node

require('dotenv').config({path: `${__dirname}/.env`});
const yargs = require('yargs/yargs')
const {hideBin} = require('yargs/helpers')
const argv = yargs(hideBin(process.argv))
    .default({size: '1024x768'})
    .demandOption(['room'])
    .describe('size', 'The size of recorded video(s)')
    .describe('room', 'The ID of the room to record').argv;

const axios = require('axios').create({
    headers: {
        Authorization: 'Bearer ' + process.env['ICE_API_TOKEN'],
        Accept: 'application/json'
    }
});
const {PassThrough} = require('stream');
const fs = require('fs');
const Websocket = require('ws');
const {RTCAudioSink, RTCVideoSink} = require('wrtc').nonstandard;
const {RTCPeerConnection, RTCIceCandidate, RTCSessionDescription} = require('wrtc');
const ffmpeg = require('fluent-ffmpeg');
const {StreamInput} = require('fluent-ffmpeg-multistream');

const VIDEO_OUTPUT_SIZE = argv.size;
const VIDEO_INPUT_DIR = `./storage/app/${argv.room}`;
const VIDEO_OUTPUT_FILE = `./storage/app/public/recordings/${argv.room}.mp4`;

let peers = {}, iceServers = [], signalingChannel;

function initSignalingChannel(){
    signalingChannel = new Websocket(`${process.env['PROTOCOL']}://${process.env['DOMAIN']}:${process.env['PORT']}${process.env['URL']}`);
    signalingChannel.onopen = () => {
        signalingChannel.send(JSON.stringify({
            action: 'record',
            room: argv.room
        }));
    };
    addSignalingListeners();
}

function addSignalingListeners(){
    signalingChannel.onmessage = (e) => {
        var message = JSON.parse(e.data);
        switch(message.action){
            case 'peer':
                if(peers[message.id] === undefined)
                    initRemotePeer(message.id);
                break;
            case 'answer':
                handleAnswer(message.answer, message.senderId)
                break;
            case 'candidate':
                handleCandidate(message.candidate, message.senderId);
                break;
        }
    }
}

function handleAnswer(answer, peerId){
    let connection = peers[peerId].connection;
    if(!connection.remoteDescription)
        connection.setRemoteDescription(new RTCSessionDescription(answer)).then(() => addPendingCandidates(peerId));
}

function handleCandidate(candidate, senderId){
    let connection = peers[senderId].connection;
    if(!connection.remoteDescription)
        peers[senderId].pendingCandidates.push(candidate);
    else
        connection.addIceCandidate(new RTCIceCandidate(candidate)).catch(function(e){
            console.error('Could not add received ICE candidate', e);
        });
}

function addPendingCandidates(peerId){
    peers[peerId].pendingCandidates.forEach((candidate) => handleCandidate(candidate, peerId));
    peers[peerId].pendingCandidates = [];
}

function initRemotePeer(peerId){
    peers[peerId] = {
        connection: new RTCPeerConnection({iceServers}),
        pendingSdp: null,
        pendingCandidates: [],
        stream: null
    };
    addIceListeners(peerId);
    initRecording(peerId);
    peers[peerId].connection.createOffer().then((offer) => peers[peerId].connection.setLocalDescription(offer)).then(() => {
        signalingChannel.send(JSON.stringify({
            action: 'record',
            peer: peerId,
            offer: peers[peerId].connection.localDescription
        }));
    });
}

function addIceListeners(peerId){
    let connection = peers[peerId].connection;
    connection.addEventListener('icecandidate', (e) => {
        if(e.candidate)
            signalingChannel.send(JSON.stringify({
                action: 'candidate',
                id: peerId,
                candidate: e.candidate
            }));
    });
    connection.addEventListener('icecandidateerror', (e) => {
        console.error('ICE error:', e);
    });
    connection.addEventListener('icegatheringstatechange', (e) => {
        let ice = e.target;
        if(ice.iceGatheringState == 'complete' && peers[peerId].pendingSdp != null){
            signalingChannel.send(JSON.stringify(peers[peerId].pendingSdp));
            peers[peerId].pendingSdp = null;
        }
    });
}

function initRecording(peerId){
    let connection = peers[peerId].connection;
    const audioSink = new RTCAudioSink(connection.addTransceiver('audio').receiver.track);
    const videoSink = new RTCVideoSink(connection.addTransceiver('video').receiver.track);

    videoSink.addEventListener('frame', ({frame: {width, height, data}}) => {
        const size = width + 'x' + height;
        if(!peers[peerId].stream){
            const stream = {
                recordPath: `${VIDEO_INPUT_DIR}/${peerId}-${size}.mp4`,
                size,
                video: new PassThrough(),
                audio: new PassThrough()
            };
            const onAudioData = ({samples: {buffer}}) => {
                if(!stream.end){
                    stream.audio.push(Buffer.from(buffer));
                }
            };
            audioSink.addEventListener('data', onAudioData);
            stream.audio.on('end', () => {
                audioSink.removeEventListener('data', onAudioData);
            });
            peers[peerId].stream = stream;

            stream.proc = ffmpeg()
                .addInput((new StreamInput(stream.video)).url)
                .addInputOptions([
                    '-f', 'rawvideo',
                    '-pix_fmt', 'yuv420p',
                    '-s', stream.size,
                    '-r', '30',
                ])
                .addInput((new StreamInput(stream.audio)).url)
                .addInputOptions([
                    '-f s16le',
                    '-ar 48k'
                ])
                .on('start', () => {
                    console.log('Started recording to ', stream.recordPath)
                })
                .on('end', () => {
                    stream.recordEnd = true;
                    console.log('Stopped recording to ', stream.recordPath)
                })
                .size(VIDEO_OUTPUT_SIZE)
                .output(stream.recordPath);
            stream.proc.run();
        }
        peers[peerId].stream.video.push(Buffer.from(data));
    });

    connection.addEventListener('connectionstatechange', () => {
        if(['disconnected', 'closed'].includes(connection.connectionState)){
            audioSink.stop();
            videoSink.stop();
            if(!peers[peerId].stream.end){
                if(peers[peerId].stream.audio)
                    peers[peerId].stream.audio.end();
                peers[peerId].stream.video.end();
                peers[peerId].stream.end = true;
            }
        }
    });
}

function mergeStreams(){
    let i, proc = ffmpeg().on('start', () => {
        console.log('Start merging into ' + VIDEO_OUTPUT_FILE);
    }).on('end', () => {
        for(i in peers)
            fs.unlinkSync(peers[i].stream.recordPath);
        console.log('Finished merging ' + VIDEO_OUTPUT_FILE);
        process.exit();
    });
    for(i in peers)
        proc.addInput(peers[i].stream.recordPath)
    proc.output(VIDEO_OUTPUT_FILE).run();
}

// Checks if all peers went offline to merge their recordings before successfully terminating the process.
let peersLoop = setInterval(() => {
    let peersCount = Object.keys(peers).length, offlineCount = 0;
    if(peersCount == 0)
        return;
    for(var id in peers)
        if(peers[id].stream && peers[id].stream.end)
            offlineCount++;
    if(offlineCount == peersCount){
        clearInterval(peersLoop);
        mergeStreams();
    }
}, 1000);

// Starts the recording service for the given room.
axios.get(process.env['ICE_API_URL']).then((response) => {
    if(!fs.existsSync(VIDEO_INPUT_DIR))
        fs.mkdirSync(VIDEO_INPUT_DIR, {recursive: true});
    iceServers = response.iceServers;
    initSignalingChannel();
}).catch((error) => console.log(error));